### 冒泡排序
介绍：两层循环，第一层循环控制循环次数，比如5个数排序，需要循环四次，4个数排序，需要循环3次，以此类推。
第二层循环控制两两比较次数，五个数第一次循环需要比较4次，第二次需要比较三次，以此类推。本次冒泡排序采取的是每次保证把最小的数排到最前面，当然也可以采样每次把最大的数冒到最后面，效果一样。
```
//采取的是每次保证把最小的数排到最前面
function bubble(Array){
	for(var i=0;i<Array.length-1;i++){
		for(var j=Array.length-1-1;j>=i;j--){
			if(Array[j]>Array[j+1]){
				var t
				t=Array[j]
				Array[j]=Array[j+1]
				Array[j+1]=t
			}
		}
	}
	return Array
}
//采取的是每次保证把最大的数排到最前面
function bubble(Array){
	for(var i=0;i<Array.length-1;i++){
		for(var j=0;j<Array.length-i-1;j++){
			if(Array[j]>Array[j+1]){
				var t
				t=Array[j]
				Array[j]=Array[j+1]
				Array[j+1]=t
			}
		}
	}
	return Array
}
```
### 选择排序

### 稳定排序
1. 冒泡排序 2.插入排序 3. 归并排序 4. 基数排序
### 不稳定排序
1. 快速排序 2 选择排序 3. 堆排序 4. 希尔排序
### 二分查找
```
function binary_search(Array,value){
	if(Array[0]>Array[Array.length-1]||value<Array[0]||value>Array[Array.length-1]){
		return false
	}
	else{
		let min=0
		let max=Array.length-1
		let mid=Math.floor((min+max)/2)
		console.log(min,mid,max)
		while((max-min)>=1){
			if(max-min==1){if(value==Array[min]){return min}else if(value==Array[max]){return max}else{return false}}
			else{
        if(value>Array[mid]){min=mid;mid=Math.floor((min+max)/2);console.log(min,mid,max)}
        else if(value<Array[mid]){max=mid;mid=Math.floor((min+max)/2);console.log(min,mid,max)}
        else{return mid}
			}
		}
	}
}
```
